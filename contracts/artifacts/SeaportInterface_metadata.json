{
	"compiler": {
		"version": "0.8.13+commit.abaa5c0e"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "zone",
								"type": "address"
							},
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifierOrCriteria",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "startAmount",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endAmount",
										"type": "uint256"
									}
								],
								"internalType": "struct OfferItem[]",
								"name": "offer",
								"type": "tuple[]"
							},
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifierOrCriteria",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "startAmount",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endAmount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ConsiderationItem[]",
								"name": "consideration",
								"type": "tuple[]"
							},
							{
								"internalType": "enum OrderType",
								"name": "orderType",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "startTime",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "endTime",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "zoneHash",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "salt",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "counter",
								"type": "uint256"
							}
						],
						"internalType": "struct OrderComponents[]",
						"name": "orders",
						"type": "tuple[]"
					}
				],
				"name": "cancel",
				"outputs": [
					{
						"internalType": "bool",
						"name": "cancelled",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "uint120",
								"name": "numerator",
								"type": "uint120"
							},
							{
								"internalType": "uint120",
								"name": "denominator",
								"type": "uint120"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "extraData",
								"type": "bytes"
							}
						],
						"internalType": "struct AdvancedOrder",
						"name": "advancedOrder",
						"type": "tuple"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "enum Side",
								"name": "side",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "index",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "identifier",
								"type": "uint256"
							},
							{
								"internalType": "bytes32[]",
								"name": "criteriaProof",
								"type": "bytes32[]"
							}
						],
						"internalType": "struct CriteriaResolver[]",
						"name": "criteriaResolvers",
						"type": "tuple[]"
					},
					{
						"internalType": "bytes32",
						"name": "fulfillerConduitKey",
						"type": "bytes32"
					},
					{
						"internalType": "address",
						"name": "recipient",
						"type": "address"
					}
				],
				"name": "fulfillAdvancedOrder",
				"outputs": [
					{
						"internalType": "bool",
						"name": "fulfilled",
						"type": "bool"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "uint120",
								"name": "numerator",
								"type": "uint120"
							},
							{
								"internalType": "uint120",
								"name": "denominator",
								"type": "uint120"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "extraData",
								"type": "bytes"
							}
						],
						"internalType": "struct AdvancedOrder[]",
						"name": "advancedOrders",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "enum Side",
								"name": "side",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "index",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "identifier",
								"type": "uint256"
							},
							{
								"internalType": "bytes32[]",
								"name": "criteriaProof",
								"type": "bytes32[]"
							}
						],
						"internalType": "struct CriteriaResolver[]",
						"name": "criteriaResolvers",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "itemIndex",
								"type": "uint256"
							}
						],
						"internalType": "struct FulfillmentComponent[][]",
						"name": "offerFulfillments",
						"type": "tuple[][]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "itemIndex",
								"type": "uint256"
							}
						],
						"internalType": "struct FulfillmentComponent[][]",
						"name": "considerationFulfillments",
						"type": "tuple[][]"
					},
					{
						"internalType": "bytes32",
						"name": "fulfillerConduitKey",
						"type": "bytes32"
					},
					{
						"internalType": "address",
						"name": "recipient",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "maximumFulfilled",
						"type": "uint256"
					}
				],
				"name": "fulfillAvailableAdvancedOrders",
				"outputs": [
					{
						"internalType": "bool[]",
						"name": "availableOrders",
						"type": "bool[]"
					},
					{
						"components": [
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifier",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ReceivedItem",
								"name": "item",
								"type": "tuple"
							},
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							}
						],
						"internalType": "struct Execution[]",
						"name": "executions",
						"type": "tuple[]"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct SeaportInterface.OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct SeaportInterface.ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum SeaportInterface.OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct SeaportInterface.OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct SeaportInterface.Order[]",
						"name": "orders",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "itemIndex",
								"type": "uint256"
							}
						],
						"internalType": "struct FulfillmentComponent[][]",
						"name": "offerFulfillments",
						"type": "tuple[][]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "itemIndex",
								"type": "uint256"
							}
						],
						"internalType": "struct FulfillmentComponent[][]",
						"name": "considerationFulfillments",
						"type": "tuple[][]"
					},
					{
						"internalType": "bytes32",
						"name": "fulfillerConduitKey",
						"type": "bytes32"
					},
					{
						"internalType": "uint256",
						"name": "maximumFulfilled",
						"type": "uint256"
					}
				],
				"name": "fulfillAvailableOrders",
				"outputs": [
					{
						"internalType": "bool[]",
						"name": "availableOrders",
						"type": "bool[]"
					},
					{
						"components": [
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifier",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ReceivedItem",
								"name": "item",
								"type": "tuple"
							},
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							}
						],
						"internalType": "struct Execution[]",
						"name": "executions",
						"type": "tuple[]"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "considerationToken",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "considerationIdentifier",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "considerationAmount",
								"type": "uint256"
							},
							{
								"internalType": "address payable",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "zone",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "offerToken",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "offerIdentifier",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "offerAmount",
								"type": "uint256"
							},
							{
								"internalType": "enum BasicOrderType",
								"name": "basicOrderType",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "startTime",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "endTime",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "zoneHash",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "salt",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "offererConduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "bytes32",
								"name": "fulfillerConduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "totalOriginalAdditionalRecipients",
								"type": "uint256"
							},
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct AdditionalRecipient[]",
								"name": "additionalRecipients",
								"type": "tuple[]"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct BasicOrderParameters",
						"name": "parameters",
						"type": "tuple"
					}
				],
				"name": "fulfillBasicOrder",
				"outputs": [
					{
						"internalType": "bool",
						"name": "fulfilled",
						"type": "bool"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "considerationToken",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "considerationIdentifier",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "considerationAmount",
								"type": "uint256"
							},
							{
								"internalType": "address payable",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "zone",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "offerToken",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "offerIdentifier",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "offerAmount",
								"type": "uint256"
							},
							{
								"internalType": "enum BasicOrderType",
								"name": "basicOrderType",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "startTime",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "endTime",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "zoneHash",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "salt",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "offererConduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "bytes32",
								"name": "fulfillerConduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "totalOriginalAdditionalRecipients",
								"type": "uint256"
							},
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct AdditionalRecipient[]",
								"name": "additionalRecipients",
								"type": "tuple[]"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct BasicOrderParameters",
						"name": "parameters",
						"type": "tuple"
					}
				],
				"name": "fulfillBasicOrder_efficient_6GL6yc",
				"outputs": [
					{
						"internalType": "bool",
						"name": "fulfilled",
						"type": "bool"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct SeaportInterface.OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct SeaportInterface.ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum SeaportInterface.OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct SeaportInterface.OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct SeaportInterface.Order",
						"name": "order",
						"type": "tuple"
					},
					{
						"internalType": "bytes32",
						"name": "fulfillerConduitKey",
						"type": "bytes32"
					}
				],
				"name": "fulfillOrder",
				"outputs": [
					{
						"internalType": "bool",
						"name": "fulfilled",
						"type": "bool"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "contractOfferer",
						"type": "address"
					}
				],
				"name": "getContractOffererNonce",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "nonce",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "offerer",
						"type": "address"
					}
				],
				"name": "getCounter",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "counter",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "address",
								"name": "zone",
								"type": "address"
							},
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifierOrCriteria",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "startAmount",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endAmount",
										"type": "uint256"
									}
								],
								"internalType": "struct OfferItem[]",
								"name": "offer",
								"type": "tuple[]"
							},
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifierOrCriteria",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "startAmount",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endAmount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ConsiderationItem[]",
								"name": "consideration",
								"type": "tuple[]"
							},
							{
								"internalType": "enum OrderType",
								"name": "orderType",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "startTime",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "endTime",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "zoneHash",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "salt",
								"type": "uint256"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							},
							{
								"internalType": "uint256",
								"name": "counter",
								"type": "uint256"
							}
						],
						"internalType": "struct OrderComponents",
						"name": "order",
						"type": "tuple"
					}
				],
				"name": "getOrderHash",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "orderHash",
						"type": "bytes32"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "orderHash",
						"type": "bytes32"
					}
				],
				"name": "getOrderStatus",
				"outputs": [
					{
						"internalType": "bool",
						"name": "isValidated",
						"type": "bool"
					},
					{
						"internalType": "bool",
						"name": "isCancelled",
						"type": "bool"
					},
					{
						"internalType": "uint256",
						"name": "totalFilled",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "totalSize",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "incrementCounter",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "newCounter",
						"type": "uint256"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "information",
				"outputs": [
					{
						"internalType": "string",
						"name": "version",
						"type": "string"
					},
					{
						"internalType": "bytes32",
						"name": "domainSeparator",
						"type": "bytes32"
					},
					{
						"internalType": "address",
						"name": "conduitController",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "uint120",
								"name": "numerator",
								"type": "uint120"
							},
							{
								"internalType": "uint120",
								"name": "denominator",
								"type": "uint120"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							},
							{
								"internalType": "bytes",
								"name": "extraData",
								"type": "bytes"
							}
						],
						"internalType": "struct AdvancedOrder[]",
						"name": "orders",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"internalType": "uint256",
								"name": "orderIndex",
								"type": "uint256"
							},
							{
								"internalType": "enum Side",
								"name": "side",
								"type": "uint8"
							},
							{
								"internalType": "uint256",
								"name": "index",
								"type": "uint256"
							},
							{
								"internalType": "uint256",
								"name": "identifier",
								"type": "uint256"
							},
							{
								"internalType": "bytes32[]",
								"name": "criteriaProof",
								"type": "bytes32[]"
							}
						],
						"internalType": "struct CriteriaResolver[]",
						"name": "criteriaResolvers",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "orderIndex",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "itemIndex",
										"type": "uint256"
									}
								],
								"internalType": "struct FulfillmentComponent[]",
								"name": "offerComponents",
								"type": "tuple[]"
							},
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "orderIndex",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "itemIndex",
										"type": "uint256"
									}
								],
								"internalType": "struct FulfillmentComponent[]",
								"name": "considerationComponents",
								"type": "tuple[]"
							}
						],
						"internalType": "struct Fulfillment[]",
						"name": "fulfillments",
						"type": "tuple[]"
					},
					{
						"internalType": "address",
						"name": "recipient",
						"type": "address"
					}
				],
				"name": "matchAdvancedOrders",
				"outputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifier",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ReceivedItem",
								"name": "item",
								"type": "tuple"
							},
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							}
						],
						"internalType": "struct Execution[]",
						"name": "executions",
						"type": "tuple[]"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct SeaportInterface.OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct SeaportInterface.ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum SeaportInterface.OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct SeaportInterface.OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct SeaportInterface.Order[]",
						"name": "orders",
						"type": "tuple[]"
					},
					{
						"components": [
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "orderIndex",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "itemIndex",
										"type": "uint256"
									}
								],
								"internalType": "struct FulfillmentComponent[]",
								"name": "offerComponents",
								"type": "tuple[]"
							},
							{
								"components": [
									{
										"internalType": "uint256",
										"name": "orderIndex",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "itemIndex",
										"type": "uint256"
									}
								],
								"internalType": "struct FulfillmentComponent[]",
								"name": "considerationComponents",
								"type": "tuple[]"
							}
						],
						"internalType": "struct Fulfillment[]",
						"name": "fulfillments",
						"type": "tuple[]"
					}
				],
				"name": "matchOrders",
				"outputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "enum ItemType",
										"name": "itemType",
										"type": "uint8"
									},
									{
										"internalType": "address",
										"name": "token",
										"type": "address"
									},
									{
										"internalType": "uint256",
										"name": "identifier",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "amount",
										"type": "uint256"
									},
									{
										"internalType": "address payable",
										"name": "recipient",
										"type": "address"
									}
								],
								"internalType": "struct ReceivedItem",
								"name": "item",
								"type": "tuple"
							},
							{
								"internalType": "address",
								"name": "offerer",
								"type": "address"
							},
							{
								"internalType": "bytes32",
								"name": "conduitKey",
								"type": "bytes32"
							}
						],
						"internalType": "struct Execution[]",
						"name": "executions",
						"type": "tuple[]"
					}
				],
				"stateMutability": "payable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "name",
				"outputs": [
					{
						"internalType": "string",
						"name": "contractName",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"components": [
									{
										"internalType": "address",
										"name": "offerer",
										"type": "address"
									},
									{
										"internalType": "address",
										"name": "zone",
										"type": "address"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											}
										],
										"internalType": "struct SeaportInterface.OfferItem[]",
										"name": "offer",
										"type": "tuple[]"
									},
									{
										"components": [
											{
												"internalType": "enum SeaportInterface.ItemType",
												"name": "itemType",
												"type": "uint8"
											},
											{
												"internalType": "address",
												"name": "token",
												"type": "address"
											},
											{
												"internalType": "uint256",
												"name": "identifierOrCriteria",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "startAmount",
												"type": "uint256"
											},
											{
												"internalType": "uint256",
												"name": "endAmount",
												"type": "uint256"
											},
											{
												"internalType": "address payable",
												"name": "recipient",
												"type": "address"
											}
										],
										"internalType": "struct SeaportInterface.ConsiderationItem[]",
										"name": "consideration",
										"type": "tuple[]"
									},
									{
										"internalType": "enum SeaportInterface.OrderType",
										"name": "orderType",
										"type": "uint8"
									},
									{
										"internalType": "uint256",
										"name": "startTime",
										"type": "uint256"
									},
									{
										"internalType": "uint256",
										"name": "endTime",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "zoneHash",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "salt",
										"type": "uint256"
									},
									{
										"internalType": "bytes32",
										"name": "conduitKey",
										"type": "bytes32"
									},
									{
										"internalType": "uint256",
										"name": "totalOriginalConsiderationItems",
										"type": "uint256"
									}
								],
								"internalType": "struct SeaportInterface.OrderParameters",
								"name": "parameters",
								"type": "tuple"
							},
							{
								"internalType": "bytes",
								"name": "signature",
								"type": "bytes"
							}
						],
						"internalType": "struct SeaportInterface.Order[]",
						"name": "orders",
						"type": "tuple[]"
					}
				],
				"name": "validate",
				"outputs": [
					{
						"internalType": "bool",
						"name": "validated",
						"type": "bool"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"author": "0age",
			"custom:version": "1.5",
			"details": "SeaportInterface contains all external function interfaces for Seaport.",
			"kind": "dev",
			"methods": {
				"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])": {
					"params": {
						"orders": "The orders to cancel."
					},
					"returns": {
						"cancelled": "A boolean indicating whether the supplied orders have                   been successfully cancelled."
					}
				},
				"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)": {
					"params": {
						"advancedOrder": "The order to fulfill along with the fraction                            of the order to attempt to fill. Note that                            both the offerer and the fulfiller must first                            approve this contract (or their preferred                            conduit if indicated by the order) to transfer                            any relevant tokens on their behalf and that                            contracts must implement `onERC1155Received`                            to receive ERC1155 tokens as consideration.                            Also note that all offer and consideration                            components must have no remainder after                            multiplication of the respective amount with                            the supplied fraction for the partial fill to                            be considered valid.",
						"criteriaResolvers": "An array where each element contains a                            reference to a specific offer or                            consideration, a token identifier, and a proof                            that the supplied token identifier is                            contained in the merkle root held by the item                            in question's criteria element. Note that an                            empty criteria indicates that any                            (transferable) token identifier on the token                            in question is valid and that no associated                            proof needs to be supplied.",
						"fulfillerConduitKey": "A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used, with direct approvals set on                            Seaport.",
						"recipient": "The intended recipient for all received items,                            with `address(0)` indicating that the caller                            should receive the items."
					},
					"returns": {
						"fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
					}
				},
				"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)": {
					"params": {
						"advancedOrders": "The orders to fulfill along with the                                  fraction of those orders to attempt to                                  fill. Note that both the offerer and the                                  fulfiller must first approve this                                  contract (or their preferred conduit if                                  indicated by the order) to transfer any                                  relevant tokens on their behalf and that                                  contracts must implement                                  `onERC1155Received` to enable receipt of                                  ERC1155 tokens as consideration. Also                                  note that all offer and consideration                                  components must have no remainder after                                  multiplication of the respective amount                                  with the supplied fraction for an                                  order's partial fill amount to be                                  considered valid.",
						"considerationFulfillments": "An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.",
						"criteriaResolvers": "An array where each element contains a                                  reference to a specific offer or                                  consideration, a token identifier, and a                                  proof that the supplied token identifier                                  is contained in the merkle root held by                                  the item in question's criteria element.                                  Note that an empty criteria indicates                                  that any (transferable) token                                  identifier on the token in question is                                  valid and that no associated proof needs                                  to be supplied.",
						"fulfillerConduitKey": "A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used, with                                  direct approvals set on this contract.",
						"maximumFulfilled": "The maximum number of orders to fulfill.",
						"offerFulfillments": "An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.",
						"recipient": "The intended recipient for all received                                  items, with `address(0)` indicating that                                  the caller should receive the items."
					},
					"returns": {
						"availableOrders": "An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.",
						"executions": "     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders. Note that unspent offer item amounts or                         native tokens will not be reflected as part of                         this array."
					}
				},
				"fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)": {
					"params": {
						"considerationFulfillments": "An array of FulfillmentComponent arrays                                  indicating which consideration items to                                  attempt to aggregate when preparing                                  executions.",
						"fulfillerConduitKey": "A bytes32 value indicating what conduit,                                  if any, to source the fulfiller's token                                  approvals from. The zero hash signifies                                  that no conduit should be used, with                                  direct approvals set on this contract.",
						"maximumFulfilled": "The maximum number of orders to fulfill.",
						"offerFulfillments": "An array of FulfillmentComponent arrays                                  indicating which offer items to attempt                                  to aggregate when preparing executions.",
						"orders": "The orders to fulfill. Note that both                                  the offerer and the fulfiller must first                                  approve this contract (or the                                  corresponding conduit if indicated) to                                  transfer any relevant tokens on their                                  behalf and that contracts must implement                                  `onERC1155Received` to receive ERC1155                                  tokens as consideration."
					},
					"returns": {
						"availableOrders": "An array of booleans indicating if each order                         with an index corresponding to the index of the                         returned boolean was fulfillable or not.",
						"executions": "     An array of elements indicating the sequence of                         transfers performed as part of matching the given                         orders. Note that unspent offer item amounts or                         native tokens will not be reflected as part of                         this array."
					}
				},
				"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
					"params": {
						"parameters": "Additional information on the fulfilled order. Note                   that the offerer must first approve this contract (or                   their preferred conduit if indicated by the order) for                   their offered ERC721 token to be transferred."
					},
					"returns": {
						"fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
					}
				},
				"fulfillBasicOrder_efficient_6GL6yc((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
					"params": {
						"parameters": "Additional information on the fulfilled order. Note                   that the offerer must first approve this contract (or                   their preferred conduit if indicated by the order) for                   their offered ERC721 token to be transferred."
					},
					"returns": {
						"fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
					}
				},
				"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": {
					"params": {
						"fulfillerConduitKey": "A bytes32 value indicating what conduit, if                            any, to source the fulfiller's token approvals                            from. The zero hash signifies that no conduit                            should be used, with direct approvals set on                            Seaport.",
						"order": "The order to fulfill. Note that both the                            offerer and the fulfiller must first approve                            this contract (or the corresponding conduit if                            indicated) to transfer any relevant tokens on                            their behalf and that contracts must implement                            `onERC1155Received` to receive ERC1155 tokens                            as consideration."
					},
					"returns": {
						"fulfilled": "A boolean indicating whether the order has been                   successfully fulfilled."
					}
				},
				"getCounter(address)": {
					"params": {
						"offerer": "The offerer in question."
					},
					"returns": {
						"counter": "The current counter."
					}
				},
				"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": {
					"params": {
						"order": "The components of the order."
					},
					"returns": {
						"orderHash": "The order hash."
					}
				},
				"getOrderStatus(bytes32)": {
					"params": {
						"orderHash": "The order hash in question."
					},
					"returns": {
						"isCancelled": "A boolean indicating whether the order in question                     has been cancelled.",
						"isValidated": "A boolean indicating whether the order in question                     has been validated (i.e. previously approved or                     partially filled).",
						"totalFilled": "The total portion of the order that has been filled                     (i.e. the \"numerator\").",
						"totalSize": "  The total size of the order that is either filled or                     unfilled (i.e. the \"denominator\")."
					}
				},
				"incrementCounter()": {
					"returns": {
						"newCounter": "The new counter."
					}
				},
				"information()": {
					"returns": {
						"conduitController": "The conduit Controller set for this contract.",
						"domainSeparator": "  The domain separator for this contract.",
						"version": "          The contract version."
					}
				},
				"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[],address)": {
					"params": {
						"criteriaResolvers": "An array where each element contains a reference                          to a specific order as well as that order's                          offer or consideration, a token identifier, and                          a proof that the supplied token identifier is                          contained in the order's merkle root. Note that                          an empty root indicates that any (transferable)                          token identifier is valid and that no associated                          proof needs to be supplied.",
						"fulfillments": "An array of elements allocating offer components                          to consideration components. Note that each                          consideration component must be fully met in                          order for the match operation to be valid.",
						"orders": "The advanced orders to match. Note that both the                          offerer and fulfiller on each order must first                          approve this contract (or a preferred conduit if                          indicated by the order) to transfer any relevant                          tokens on their behalf and each consideration                          recipient must implement `onERC1155Received` in                          order to receive ERC1155 tokens. Also note that                          the offer and consideration components for each                          order must have no remainder after multiplying                          the respective amount with the supplied fraction                          in order for the group of partial fills to be                          considered valid.",
						"recipient": "The intended recipient for all unspent offer                          item amounts, or the caller if the null address                          is supplied."
					},
					"returns": {
						"executions": "An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders. Note that unspent offer item amounts or native                    tokens will not be reflected as part of this array."
					}
				},
				"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
					"params": {
						"fulfillments": "An array of elements allocating offer components to                     consideration components. Note that each                     consideration component must be fully met for the                     match operation to be valid.",
						"orders": "The orders to match. Note that both the offerer and                     fulfiller on each order must first approve this                     contract (or their conduit if indicated by the order)                     to transfer any relevant tokens on their behalf and                     each consideration recipient must implement                     `onERC1155Received` to enable ERC1155 token receipt."
					},
					"returns": {
						"executions": "An array of elements indicating the sequence of                    transfers performed as part of matching the given                    orders. Note that unspent offer item amounts or                    native tokens will not be reflected as part of this                    array."
					}
				},
				"name()": {
					"returns": {
						"contractName": "The name of this contract."
					}
				},
				"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])": {
					"params": {
						"orders": "The orders to validate."
					},
					"returns": {
						"validated": "A boolean indicating whether the supplied orders have                   been successfully validated."
					}
				}
			},
			"title": "SeaportInterface",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"cancel((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256)[])": {
					"notice": "Cancel an arbitrary number of orders. Note that only the offerer         or the zone of a given order may cancel it. Callers should ensure         that the intended order was cancelled by calling `getOrderStatus`         and confirming that `isCancelled` returns `true`."
				},
				"fulfillAdvancedOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes),(uint256,uint8,uint256,uint256,bytes32[])[],bytes32,address)": {
					"notice": "Fill an order, fully or partially, with an arbitrary number of         items for offer and consideration alongside criteria resolvers         containing specific token identifiers and associated proofs."
				},
				"fulfillAvailableAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,address,uint256)": {
					"notice": "Attempt to fill a group of orders, fully or partially, with an         arbitrary number of items for offer and consideration per order         alongside criteria resolvers containing specific token         identifiers and associated proofs. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail."
				},
				"fulfillAvailableOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],(uint256,uint256)[][],(uint256,uint256)[][],bytes32,uint256)": {
					"notice": "Attempt to fill a group of orders, each with an arbitrary number         of items for offer and consideration. Any order that is not         currently active, has already been fully filled, or has been         cancelled will be omitted. Remaining offer and consideration         items will then be aggregated where possible as indicated by the         supplied offer and consideration component arrays and aggregated         items will be transferred to the fulfiller or to each intended         recipient, respectively. Note that a failing item transfer or an         issue with order formatting will cause the entire batch to fail.         Note that this function does not support criteria-based orders or         partial filling of orders (though filling the remainder of a         partially-filled order is supported)."
				},
				"fulfillBasicOrder((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
					"notice": "Fulfill an order offering an ERC721 token by supplying Ether (or         the native token for the given chain) as consideration for the         order. An arbitrary number of \"additional recipients\" may also be         supplied which will each receive native tokens from the fulfiller         as consideration."
				},
				"fulfillBasicOrder_efficient_6GL6yc((address,uint256,uint256,address,address,address,uint256,uint256,uint8,uint256,uint256,bytes32,uint256,bytes32,bytes32,uint256,(uint256,address)[],bytes))": {
					"notice": "Fulfill an order offering an ERC721 token by supplying Ether (or         the native token for the given chain) as consideration for the         order. An arbitrary number of \"additional recipients\" may also be         supplied which will each receive native tokens from the fulfiller         as consideration. Note that this function costs less gas than         `fulfillBasicOrder` due to the zero bytes in the function         selector (0x00000000) which also results in earlier function         dispatch."
				},
				"fulfillOrder(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes),bytes32)": {
					"notice": "Fulfill an order with an arbitrary number of items for offer and         consideration. Note that this function does not support         criteria-based orders or partial filling of orders (though         filling the remainder of a partially-filled order is supported)."
				},
				"getCounter(address)": {
					"notice": "Retrieve the current counter for a given offerer."
				},
				"getOrderHash((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256))": {
					"notice": "Retrieve the order hash for a given order."
				},
				"getOrderStatus(bytes32)": {
					"notice": "Retrieve the status of a given order by hash, including whether         the order has been cancelled or validated and the fraction of the         order that has been filled."
				},
				"incrementCounter()": {
					"notice": "Cancel all orders from a given offerer with a given zone in bulk         by incrementing a counter. Note that only the offerer may         increment the counter."
				},
				"information()": {
					"notice": "Retrieve configuration information for this contract."
				},
				"matchAdvancedOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),uint120,uint120,bytes,bytes)[],(uint256,uint8,uint256,uint256,bytes32[])[],((uint256,uint256)[],(uint256,uint256)[])[],address)": {
					"notice": "Match an arbitrary number of full or partial orders, each with an         arbitrary number of items for offer and consideration, supplying         criteria resolvers containing specific token identifiers and         associated proofs as well as fulfillments allocating offer         components to consideration components. Any unspent offer item         amounts will be transferred to the designated recipient (with the         null address signifying to use the caller) and any unspent native         tokens will be returned to the caller."
				},
				"matchOrders(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[],((uint256,uint256)[],(uint256,uint256)[])[])": {
					"notice": "Match an arbitrary number of orders, each with an arbitrary         number of items for offer and consideration along with a set of         fulfillments allocating offer components to consideration         components. Note that this function does not support         criteria-based or partial filling of orders (though filling the         remainder of a partially-filled order is supported). Any unspent         offer item amounts or native tokens will be transferred to the         caller."
				},
				"name()": {
					"notice": "Retrieve the name of this contract."
				},
				"validate(((address,address,(uint8,address,uint256,uint256,uint256)[],(uint8,address,uint256,uint256,uint256,address)[],uint8,uint256,uint256,bytes32,uint256,bytes32,uint256),bytes)[])": {
					"notice": "Validate an arbitrary number of orders, thereby registering their         signatures as valid and allowing the fulfiller to skip signature         verification on fulfillment. Note that validated orders may still         be unfulfillable due to invalid item amounts or other factors;         callers should determine whether validated orders are fulfillable         by simulating the fulfillment call prior to execution. Also note         that anyone can validate a signed order, but only the offerer can         validate an order without supplying a signature."
				}
			},
			"notice": "Seaport is a generalized native token/ERC20/ERC721/ERC1155         marketplace. It minimizes external calls to the greatest extent         possible and provides lightweight methods for common routes as well         as more flexible methods for composing advanced orders.",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/ISeaport.sol": "SeaportInterface"
		},
		"evmVersion": "london",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/ISeaport.sol": {
			"keccak256": "0x086f18d959f3bda2aa8b712e68d5d26b28f9325844ee0465bef7865c9359b7ba",
			"license": "MIT",
			"urls": [
				"bzz-raw://a505e35aefb91bd606cafd72366e90a94dde939a6301c9dc2dd1c8f6bfc1f1fc",
				"dweb:/ipfs/QmewWw6KtzG4ZnAyo6ZVFdStit2vgrcVKcPuuTyTd5YMPE"
			]
		},
		"https://github.com/ProjectOpenSea/seaport-types/blob/0bd56c08d485ee5b3d5a20b0482a35a8ada60256/src/helpers/PointerLibraries.sol": {
			"keccak256": "0xf9106392d8616040b61748bce0ff35856c4a3eba5eb5eb269eaeb97747fe40e7",
			"license": "MIT",
			"urls": [
				"bzz-raw://046f05ce4d4428d3ca6264ab03e1b6cee5751776f02cc87d66d11ee479a42992",
				"dweb:/ipfs/Qme5bKudPZWxH4DYDLQE2sD23xNVbQH4NjrL6pBacv54FD"
			]
		},
		"https://github.com/ProjectOpenSea/seaport-types/blob/0bd56c08d485ee5b3d5a20b0482a35a8ada60256/src/lib/ConsiderationEnums.sol": {
			"keccak256": "0xeb0de4edbad252c3227c59b66721978316202c4d31c5370a8669c4051984e345",
			"license": "MIT",
			"urls": [
				"bzz-raw://00451d1ceb616b7cccf0e4be073483d5c99fcc205fe6a1056ce35b8703be16e3",
				"dweb:/ipfs/QmbeoxgRcgwK18Vw1G1mVAFKMnYYT2oQp1idfazNicwncq"
			]
		},
		"https://github.com/ProjectOpenSea/seaport-types/blob/0bd56c08d485ee5b3d5a20b0482a35a8ada60256/src/lib/ConsiderationStructs.sol": {
			"keccak256": "0x05bc9ccb74c9fb4d073c9adc36da28a5a0ab961886fcd4a681ccb8d7eb74e0ed",
			"license": "MIT",
			"urls": [
				"bzz-raw://911be5f248b2ad47a24ca9949f4b8114db5432c7f2769650c0f3e4ea6bb0b17b",
				"dweb:/ipfs/QmdNmqhwc1UMxbCPXqe9FDua7negVWSGU5cPAWSbUTnKDV"
			]
		}
	},
	"version": 1
}